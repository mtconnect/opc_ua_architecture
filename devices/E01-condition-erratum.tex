
\section{OPC UA Companion Specification: \getdoctitle}
\FloatBarrier

\begin{table}[ht]
  \centering 
  \tabulinesep=6pt
  \begin{tabu} to 6in {|l|X|} \everyrow{\hline}
    \hline
    \bfseries {Topic} & {Mapping the Native Code to a Condition Branch Semantic Correction} \\
    \bfseries {Errata Version} & 2.00.00 \\
    \bfseries {Spec Reference} & {\getdoctitlepart \vspace{3pt} \par 8.4.6 Conditions, 9.4 Conditions} \\
    \bfseries {Mantis Reference} & \mantis{4883} \\
    \bfseries {Problem Statement} & \small{
      While mapping an MTConnect NativeCode to the OPC UA Conditoion BranchID my technically allow OPC UA to represent all the possible states of the MTConnect system, it is semantically not the same meaning, and standard OPC UA Client tools, will create misleading views of these systems states.
      
      \vspace{6pt}
      From the \cite{UAPart9} page 5:
      \textit{Condition instances are specific implementations of a ConditionType. It is up to the Server whether such instances are also exposed in the Serverâ€™s AddressSpace. Clause 4.10 provides additional background about Condition instances. Condition instances shall have a unique identifier to differentiate them from other instances. This is independent of whether they are exposed in the AddressSpace. As mentioned above, Conditions represent the state of a system or one of its components.}

      \vspace{6pt}
      The different native Codes in MTConnect represent different conditions. They do not represent ID's for previous occurrences of the same condition. Each NativeCode is a different condition. Each native Code will have a different operator action to resolve, there is no notion of the them representing previous occurrences of interest of the same condition like the OPC UA BranchId.

      \vspace{6pt}
      From the \cite{UAPart9} Page 5:
      \textit{In certain cases, however, previous states that still need attention also have to be maintained. ConditionBranches are introduced to deal with this requirement and distinguish current state and previous states. Each ConditionBranch has a BranchId that differentiates it from other branches of the same Condition instance. The ConditionBranch which represents the current state of the Condition (the trunk) has a NULL BranchId.}
      } \\
  \end{tabu}
\end{table}

Continued next page...

\begin{table}[ht]
  \centering 
  \tabulinesep=6pt
  \begin{tabu} to 6in {|l|X|} \everyrow{\hline}
    \hline
    \bfseries {Solution} &
    {
      The change removes the use of branches to differentiate individual \mtmodel{Condition} activation and relies on the \uamodel{ConditionType} \uamodel{Event} mechanism to manage the \mtmodel{Condition} states.
      \vspace{6pt}
      
      The solution separates out the \mtuatype{MTConnditionType} representing meta-data and the \mtuatype{MTConditionEventType} that represents the information reported when a \mtmodel{Warning} or \mtmodel{Fault} occurs. Each unique condition invocation, usually distinguished by the \mtmodel{nativeCode} will become a new \mtuatype{MTConditionEventType} with a unique \uamodel{ConditionId} given as the \uamodel{NodeId} of the \uamodel{Event} and a composed unique \uamodel{ConditionName} composed from the unique attributes of the \mtmodel{Condition} in the stream document.

      \vspace{6pt}
      The \uamodel{Event} connects to the \mtuamodel{MTConditionType} meta-data \uamodel{Object} with the \uamodel{SourceNode} and \uamodel{SourceName} properties.

      
      \vspace{12pt}
      \textbf{Modified Sections:}
      \begin{itemize}
        \item Modifications to Section~\ref{sec:mapping-conditions}   
        \item Modifications to Section~\ref{model:Conditions}
      \end{itemize}
    }\\
  \end{tabu}
\end{table}


\FloatBarrier

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "errata"
%%% End:
