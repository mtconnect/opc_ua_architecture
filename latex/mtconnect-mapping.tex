\section{Mapping the MTConnect Information Model to OPC UA} 
  \label{mtconnect-mapping}

This section details translating the MTConnect model into a UML representation to render the MTConnect information model in OPC UA. More detailed information is provided in Section \ref{mtconnect_information_model} for each data type.

OPC UA defines abstractions representing data collected from devices and for alarms and conditions. The abstractions do not provide the semantic meaning; they provide a structure to convey the meta-data and the values as they change. 

MTConnect has similar facilities but uses different structural model where the meta-data and the streaming values are in separate documents to normalize the data flow in a similar way that many publish-subscribe protocols separate the structure from the data.

When translating from MTConnect to OPC UA, the MTConnect abstractions of \mtconnectterm{DataItem}s are converted using the OPC UA  \opcuaterm{DataVariable} abstractions as given in \cite{UAPart8}.  The relationships are mapped to multiple \opcuaterm{DataVariable} types where the category and the type determine the correct mapping. Conditions are mapped a sub-type of the OPC UA \opcuaterm{ConditionType} in a similar way. The behavior of the OPC UA \opcuaterm{Condition}s can be found in \cite{UAPart9}.

\subsection{MTConnect UML Representation of OPC}

This section provides a guide to converting from the OPC UA diagram representation given in section \ref{intro-to-opc-ua} to the UML described throughout section \ref{mtconnect-mapping}. Figure \ref{fig:mtcomponent-ua} is a partial illustration of the MTConnect \mtconnectterm{Component} abstraction in OPC UA.

\input{diagrams/mtconnect-mapping/mtcomponent-ua.tex}

Figure \ref{fig:mtcomponent-uml} represents the same model in UML. The companion specification uses the following conventions:

\begin{itemize}
\item OPC UA Types are represented as UML classes
\item OPC UA Properties are denoted as UML attributes. UA attributes are also represented as UML Attributes with the stereotype of \mtconnectterm{<<attribute>>}.
\item OPC UA Component references are represented as UML Unidirectional associations. The reference type is given as the association's \textit{Stereotype}, for example \textit{<<HasComponent>>}. 
\item HasSubtype relationships are given as an UML Generalization association.  
\end{itemize}

The UML Associations are used to represent OPC UA references. UA Properties represented using the UA \opcuaterm{Has\-Property} relationships are given as UML Attributes (not be confused with the OPC UA Attribute). UML allows for additional information as follows:  the multiplicity of a property, the data type of the property, are specified.

\input{diagrams/mtconnect-mapping/mtcomponent-uml.tex}
\FloatBarrier

When traversing an association between two object types, the name of the source of the association is the browse name associated with the object, and the destination is the type of object that is instantiated. If the name is not given, it represents a dynamic relationship where the browse name is determined during the creation of the object model. An example is the association of the MTConnect \mtconnectterm{DataItem}s.

\input{diagrams/mtconnect-mapping/data-item-uml.tex}
\FloatBarrier

A reference that has a stereotype of \textit{<<Organizes>>}, shown by the \texttt{Components} recursive relationship in the \mtconnectterm{MTComponentType}, implies an intermediate object of type \opcuaterm{FolderType} with the browse name of the relationship point on the source side. The far side is not constrained within the \opcuaterm{FolderType} but given in the documentation as the expected contents of the folder.

OPC UA represents both class and instance diagrams using the same set of primitives. UML provides separate class and object models using two separate sets of primitives, one for classification and the other for instances of those classes. This section separates the object instantiation from the classification and uses UML object diagrams to represent example instances of classes.

\FloatBarrier

\subsubsection{MTConnect UML Object Model}

The object models will use a UML representation that represents the members as UML Slots. There is no distinction between an attribute and a property; consult the type model for the proper associations.

\input{diagrams/mtconnect-mapping/example-object.tex}

Figure \ref{fig:example-object} represents an MTConnect \mtconnectterm{Device} with the values filled in. The UA \opcuaterm{Browse\-Name} is given as the object name above and the UA Type is given after the \texttt{:} in the header. Each of the UA \opcuaterm{Attributes} and \opcuaterm{Properties} are provided below. Relationships are shown as edges that have the Reference Type, such as \opcuaterm{Has\-Component} provided. The properties contains within will be created using the \opcuaterm{Has\-Property} reference, but composed as internal members for brevity.

For example, the object with \mtuatype{MTDeviceType} has \opcuaterm{BrowseName} of \texttt{SimpleCnc} (the name of the device). There are patterns for creating all the browse names for each MTConnect UA Type as deined. The rules will be presented and then examples will provide the normative patterns as example for each type as defined.

\FloatBarrier

\subsection{MTConnect Information Model}

The MTConnect information model has the following abstractions:

\begin{enumerate}
\item \component{Components}
\item \dataitem{DataItems}
\item \configuration{Configuration}
\item \composition{Compositions}
\item \asset{Assets}
\end{enumerate}

The first concern of the MTConnect OPC UA companion specification is the \texttt{Device} model covered in MTConnect \cite{MTCPart2} and \cite{MTCPart3}. The top-level \texttt{Comp\-onent} of any MTConnect information model is the \texttt{Device}. A \texttt{Comp\-onent} represents a logical part or a collection of parts of a piece of equipment. The \texttt{Data\-Item}s represent information that is communicated from \texttt{Component}s, and the representation and communication of the information are covered in \cite{MTCPart3}. The \texttt{Compositions} are leaf node components that do not have any structure but can be associated with \texttt{Data\-Item}s to provide additional context. 

The \texttt{Configuration} is a collection of information about the component that provides more detail about its capabilities. The standard has only specified the \texttt{Sensor\-Configuration} at this point.

\texttt{Asset}s are complex information models that provide a point in time consistent set of information about the use of a physical or logical entity in the manufacturing process. These models, for example, may represent a cutting tool, a program, or a process. The \texttt{Asset}s will be covered in a subsequent companion specification. The only assets currently in the MTConnect standard are \texttt{CuttingTool} and \texttt{CuttingToolArchetype}. Refer to MTConnect Part 4.0 \cite{MTCPart40} and MTConnect Part 4.1 \cite{MTCPart41}.

The specification uses examples to illustrate the process of conversion from XML to OPC UA; the following sections cover the main points and concerns when converting an MTConnect Device model to a Nodeset. Following the metamodel discussion will be a section on the handling of streaming data and mapping to the correct data items. 

\subsection{Mapping The Model}
\lstset{language=XML,numbers=left,xleftmargin=2em}

The MTConnect information model is represented in the UA address space as set of object and variable types. Most have pre-existing type definitions whereas others will be created dynamically following riles in the following section. The rules provide a way for a developer of a server to extend the nodeset to include the types present in a given MTConnectDevices XML document as presented from an MTConnect \textit{Agent} in response to a \texttt{/probe} requires.

\subsubsection{Mapping Rules and Conventions}

MTConnect has conventions regarding the format of elements, attributes, and values of attributes or CDATA the represent controlled vocabularies or enumerations. 

When the rules refer to \textit{Pascal Case}, the entity must have the following structure: The first letter of each word is capitalized and the remaining letters are in lowercase. All space is removed between letters. For example, \textit{controller mode override} becomes \texttt{Controller\-Mode\-Override}. The one exception is \texttt{PH} that remains \texttt{PH}.

The document refers to \textit{Lower Camel Case} when the first word is lowercase and the remaining words are capitalized and all spaces between words are removed. For example, \textit{controller mode override} is written as \texttt{controllerModeOverride}.

The third form used in MTConnect is uppercase with underscores separating characters. For example, \textit{controller mode override} is \texttt{CONTROLLER_MODE_OVERRIDE}.

The rules are as follows:
\begin{itemize}
\item XML Elements are in \textit{Pascal Case}.
\item XML Attributes are in \textit{Lower Camel Case}
\item Controlled vocabulary, a fixed or enumerated set of values, for attribtues or the CDATA of elements are all caps with an underscore ("\_") separating words. 
\end{itemize}

When the value of an attribute, such as the data item type as given in Listing \ref{lst:type-attr-conversion}:

\begin{lstlisting}[firstnumber=1,%
    caption={\texttt{DataItem} \texttt{type} Attribtue Conversion}, label={lst:type-attr-conversion}]
        <DataItem category="EVENT" id="a8ce34a00" name="mode_ovr" type="CONTROLLER_MODE_OVERRIDE"/>
        <DataItem category="EVENT" id="b8ce34a00" name="eob" type="END_OF_BAR"/>
\end{lstlisting}

The type names in UA will require the upper case with underscore name to be converted to \textit{Pascal Case}. XML Attributes are converted from \textit{Lower Camel Case} to \textit{Pascal Case} as well when mapping to UA Property \texttt{BrowseName}s.

OPC UA conventions use names in \textit{Pascal Case}, so all MTConnect entities will be represented using \textit{Pascal Case}. When the MTConnect entities are converted into UA types, they are converted to \textit{Pascal Case} and the word \texttt{Type} is appended. 

The values of the attributes and enumerations are represented in MTConnect in capitals with underscores. OPC UA has the same convention, so these types will remain unchanged when converted to OPC UA. The only caveat is that enumerated values when represented in UA \texttt{DataVariable}s are numeric. All enumerations in MTConnect are sorted alphabetically and assigned monotonically increasing numberic values. For example, the enumeration for the \texttt{Execution} MTConnect data item is in table \ref{table:execution-data-type}.

Extensions to the MTConnect standard that have enumerations will represent the data as strings since the values are not included in the nodeset reference. An extension nodeset can be created by a vendor if the \mtuatype{MTControlledVocabEventType} is desired. The parent type requres a reference to a UA \texttt{MultiState\-Value\-Discrete\-Type} and defines the data type as being a \texttt{Number} and has an attribute that references the \texttt{NodeId} of the enumerated values.

\begin{table}[ht]
\centering 
  \caption{\texttt{ExecutionDataType} Enumeration}
  \label{table:execution-data-type}
\tabulinesep=3pt
\begin{tabu} to 6in {|l|r|} \everyrow{\hline}
\hline
\rowfont\bfseries {Name} & {Index} \\
\tabucline[1.5pt]{}
\texttt{ACTIVE} & \texttt{0} \\
\texttt{FEED_HOLD} & \texttt{1} \\
\texttt{INTERRUPTED} & \texttt{2} \\
\texttt{OPTIONAL_STOP} & \texttt{3} \\
\texttt{READY} & \texttt{4} \\
\texttt{PROGRAM_COMPLETED} & \texttt{5} \\
\texttt{PROGRAM_STOPPED} & \texttt{6} \\
\texttt{STOPPED} & \texttt{7} \\
\end{tabu}
\end{table} 


MTConnect base types have been prefixed with the letters \texttt{MT} to avoid confusion with OPC UA vocabulary. The following component types and relationships have been annoted:

\begin{itemize}
\item $Device \rightarrow MTDeviceType$
\item $Component \rightarrow MTComponentType$
\item $Composition \rightarrow MTCompositionType$
\item $Configuration \rightarrow MTConfigurationType$
\item $Description \rightarrow MTDescriptionType$
\item $SensorConfiguration \rightarrow MTSensorConfiguration$
\item $Message \rightarrow MTMessageType$
\end{itemize}

The following types representing base MTConnect types are also prefixed:

\begin{itemize}
\item $MTAssetEventType$
\item $MTControlledVocabEventType$
\item $MTNumericEventType$
\item $MTHasClassType$
\item $MTHasSubClassType$
\item $MTStringEventType$
\item $MTSampleType$
\item $MTConnectAlarmConditionType$
\item $MTExclusiveLimitConditionType$
\item $MTNonExclusiveConditionType$
\end{itemize}

The data item class types and enumeration data types do not have \texttt{MT} prepended. Sub-types of the \mtuatype{MTComponentType} do not have \texttt{MT} prefixed with the exception of the \mtuatype{MTDeviceType}. All compositions that are sub-types of the \mtuatype{MTCompositionType} do not have any prefix.

\subsubsection{Mapping Example 1}

The first section showing in Listing \ref{lst:device-header} of the MTConnect XML representation gives the information models root element \texttt{MTConnectDevices} and the \texttt{Header} element that is used for the MTConnect protocol. The only root node concern is if there are additional namespaces declared in the root \texttt{MTConnectDevices} element. The other area of note is the \texttt{version} attribute of the \texttt{Header} element.  The version indicates the most current version of the MTConnect standard currently being provided by this \textit{Agent}. The remaining attributes are relevant during the discussion of streaming data in the following section.

\begin{lstlisting}[caption={Device Header},label={lst:device-header}]
<MTConnectDevices xmlns:m="urn:mtconnect.org:MTConnectDevices:1.3" xmlns="urn:mtconnect.org:MTConnectDevices:1.3" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:mtconnect.org:MTConnectDevices:1.3 /schemas/MTConnectDevices_1.3.xsd">
  <Header creationTime="2018-10-21T01:36:51Z" sender="1c1971b39543" instanceId="1535384774" version="1.4.0.10" assetBufferSize="1024" assetCount="0" bufferSize="1048576"/>
  <Devices>
\end{lstlisting}

The MTConnect \textit{Agent} is capable of supporting multiple \texttt{Device}s; a Device element is the only allowed member of the \texttt{Devices} element. The \texttt{Device} element is the top level component of the MTConnect component hierarchy. The \texttt{Device} is a sub-type of the \texttt{Component} and inherits all the structure of an MTConnect \texttt{Component}. The \texttt{Device} has three required attributes, an \texttt{id}, a \texttt{uuid} and a \texttt{name} attribute. Only the \texttt{id} is mandatory in all other components. 

\begin{lstlisting}[firstnumber=last,%
    caption={\texttt{Device} Element Mapping},label={lst:device-model-device}]
    <Device id="Mazak01" name="Mazak01" uuid="mtc_adapter002">
      <Description manufacturer="Mazak" model="Integrex" serialNumber="M7303290458">Mazak Integrex 100-IV</Description>
\end{lstlisting}

The \texttt{Description} element provides some characteristics of the device, namely the manufacturer, serial-number and model. These are all optional as is the descriptive text that is contained in the \texttt{Description} element. The text contained in the \cdata{CDATA} of the \texttt{Description} element is mapped to the \texttt{Data} property of the \mtuatype{MTDescription}

The \texttt{Device} is mapped to an \mtuatype{MTDevice} object in the MTConnect namespace as shown in Figure \ref{fig:mazak-01-device-model}.

\input{diagrams/mtconnect-mapping/device-model.tex}

Every device must have a \opcuaterm{HasNotifier} relationship with the server to enable conditions and event notification. The \texttt{HasNotifier} relationships are flowed down through the component hierarchy where the leaf \texttt{Component} has a \texttt{HasEventSource} relationship with its parent component. Each condition will need to have a \texttt{HasCondition} relationship with its parent component as well. 

\begin{lstlisting}[firstnumber=last,%
    caption={Device Data Items},label={lst:device-data-items}]
      <DataItems>
        <DataItem category="EVENT" id="Mazak01-dtop_1" name="avail" type="AVAILABILITY"/>
        <DataItem category="EVENT" id="Mazak01_asset_chg" type="ASSET_CHANGED"/>
        <DataItem category="EVENT" id="Mazak01_asset_rem" type="ASSET_REMOVED"/>
      </DataItems>
\end{lstlisting}

The device, as shown in Listing \ref{lst:device-data-items}, requires three data items as of MTConnect version 1.2. The \dataitem{AVAILABILITY} data item indicates if data is available from the device and the \dataitem{ASSET_CHANGED} and \dataitem{ASSET_REMOVED} data items represent the last asset inserted or updated and removed respectively. The Component adds Data items with a \texttt{Has\-Component} relationship, and the BrowseName is constructed using the \texttt{type}, \texttt{sub\-Type}, and related \texttt{Composition} from \texttt{compositionId} if given. A complete example is given later in this section.

\input{diagrams/mtconnect-mapping/mtdevice-data-item.tex}

Figure \ref{fig:mtdevice-data-item} demonstrates the relationship of the \texttt{Data\-Item}s with the parent \mtuatype{MTComponentType} using a \texttt{Has\-Component} relationship. The browse name is constructed to uniquely identify the DataItem and also indicate its semantic meaning within the context of the MTConnect \mtuatype{MTComponentType}, in this case, an \mtuatype{MTDeviceType} since the \mtuatype{MTDeviceType} is a sub-type of the \mtuatype{MTComponentType}. These relationships are created dynamically during the instantiation of the model and are not part of the underlying MTConnect Nodeset.

Every MTConnect \texttt{Data\-Item} has two references that provide the semantic meaning in the UA address space. This model is very similar to the \texttt{Condition\-Class\-Id} relationship for the OPC UA \texttt{Condition\-Type}. These \texttt{Class\-Type}s are inherited from the same tree so they can be used in the MTConnect representation of the MTConnect \dataitem{CONDITION} category \texttt{Data\-Item}s.

\input{diagrams/mtconnect-mapping/data-item-references.tex}

In Figure \ref{fig:data-item-references}, the \mtuatype{HasMTClassType} reference indicates the semantic meaning of the data item. For enumerated or controlled vocabulary data items, they are represented using a sub-type of the UA \texttt{Multi\-State\-Value\-Discrete\-Type}, the \mtuatype{MTControlledVocabEventType}, where the \texttt{Enum\-Values} attribute is related to the NodeId of the associated enumeration data type, in this case the \texttt{Availability\-Data\-Type}.

MTConnect \texttt{subType} will be mapped in the same manner as the type using the \mtuatype{HasMTSubClassType} relationship. This will be covered subsequent examples.

\begin{lstlisting}[firstnumber=last,%
    caption={Components and Conditions},label={lst:device-axis-component}]
      <Components>
        <Axes id="Mazak01-base">
          <DataItems>
            <DataItem category="CONDITION" id="Mazak01-base_1" name="servo_cond" type="ACTUATOR"/>
          </DataItems>
\end{lstlisting}

The \texttt{Components} element in Listing \ref{lst:device-axis-component} is represented as a UA \texttt{Folder\-Type}. Within the folder, the MTConnect components are semantically identified by the element's QName with a type with the suffix \texttt{Type} appended, in this case \texttt{Axes} browse name with a \texttt{HasTypeDefinition} relaton of \texttt{AxesType}. 

\input{diagrams/mtconnect-mapping/axes-example-1.tex}

The \texttt{HasNotifier} refererence needs to be created between the \texttt{Axes} object and the \texttt{Mazak01\-:\-MTDeviceType} object to allow for the condition to be associated correctly. The relationship of the condition in Figure~\ref{fig:axes-example-1} illustrates the relationships between the \texttt{Component} and the related condition and the notification hierarchy. The UA \texttt{Condition\-ClassId} and \texttt{Condition\-ClassName} use the \mtuatype{ActuatorClassType}'s \texttt{NodeId} and \texttt{BrowseName} respectively to relate to the condition class as required by the UA specification \cite{UAPart9}. In addition the MTConnect \texttt{HasMTClassType} reference directly connects to the type definition as do all MTConnect \texttt{DataItem}s.

The conditions are modeled as sub-types of the OPC UA base type of \texttt{OffNormalAlarmType} with the \texttt{NormalState} node id of the NormalState mapped to the Normal instance of the UA \texttt{UAStateType}.

\begin{quote}
    \color{red}
    TODO: Do we need to instantiate an entire state machine?
\end{quote}

\begin{lstlisting}[firstnumber=last,%
    caption={Linear X Component},label={lst:linear-x-component}]
          <Components>
            <Linear id="Mazak01-X" name="X">
              <DataItems>
                <DataItem category="SAMPLE" coordinateSystem="MACHINE" id="Mazak01-X_1" name="Xabs" nativeUnits="MILLIMETER" subType="ACTUAL" type="POSITION" units="MILLIMETER"/>
                <DataItem category="CONDITION" id="Mazak01-X_2" name="Xtravel" type="POSITION"/>
                <DataItem category="SAMPLE" id="Mazak01-X_3" name="Xload" nativeUnits="PERCENT" type="LOAD" units="PERCENT"/>
                <DataItem category="SAMPLE" id="Mazak01-X_4" name="Xfrt" nativeUnits="MILLIMETER/SECOND" type="AXIS_FEEDRATE" units="MILLIMETER/SECOND"/>
              </DataItems>
            </Linear>
\end{lstlisting}

A more complex component definition is the Linear X axis represented in Listing~\ref{lst:linear-x-component}. The Linear X Component is created with with the browse name being composed of the QName of the component element, \texttt{Linear} and the name attribute appended and enclosed in square brackets \texttt{[X]} giving the browse name of \texttt{Linear[X]} and a component type of \texttt{LinearType}.

\input{diagrams/mtconnect-mapping/linear-x-example-1.tex}

Figure~\ref{fig:linear-x-example-1} represents the UA Object model based on \ref{lst:linear-x-component}. The \texttt{Linear[x]} component is a leaf component, there are no components below it, so the \texttt{HasEventSource} relationship is used rather that the \texttt{HasNotifier}. The condition, having a \texttt{MTClassType} of \texttt{PositionClassType}, is connected to the \texttt{Linear[X]} axis with a \texttt{HasCondition} relationship.

Each of the data items in this case are samples, meaning they contain numeric values and derived from the UA \texttt{AnalogItemType} defined in \cite{UAPart8}.

\FloatBarrier

Listing~\ref{lst:controller-component} represents the control system and the paths of exectution under for each independent set of operations and motion. This controller also has extended data items that are not in the standard. They are prefixed with the XML namespace \texttt{x:}. Data item types and sub-types can be extended. If only the sub-type is an exteneded type, then the browse name will be prepended as normal and the sub type in \textit{Pascal Case} prepended. For example with the data item of type \texttt{PROGRAM} with sub-type \texttt{x:SUB} (line 36), the namespace will be removed and the browse name \texttt{SubProgram} of a \texttt{MTStringEventType} will be used referencing the \texttt{ProgramClassType}. 

When the type is an extended namespace, a new \texttt{ClassType} must be created by taking the \texttt{type} attribute, removing the namespace and creating a new subtype of the \texttt{MTString\-EventType}. A \texttt{MTString\-EventType} must be used unless a better mapping can be determined. For example, the \texttt{x:SEQUENCE_NUMBER} (line 39) data item would be have a \texttt{MTString\-EventType} instantiated with the browse name of \texttt{SequenceNumber} and a new \texttt{ClassType} will be created \texttt{Sequence\-NumberClassType} and related with the \texttt{HasMT\-ClassType} reference. The \texttt{ClassType} must be created as a sub-type of the \texttt{MTStringEventClassType}.

In this case the \texttt{SequenceNumber} may have schema or information associated with it that will determine it to be a numeric value. If this is the case, then it can be mapped to the \texttt{MTNumericEventType} as a better match. The \texttt{classType} must be created as a sub-type of the \texttt{MTNumericEventClassType}.

All data items of \texttt{category} \texttt{SAMPLE} must always be mapped to the \texttt{MTSampleType} instance with the browse name created appropriately. In this case the \texttt{ClassType} must be created as as sub-type of the \texttt{MTSampleClassType}.

\begin{lstlisting}[firstnumber=last,%
    caption={Controller and Path Components and Their Data Items},label={lst:controller-component}]
        <Controller id="Mazak01-controller" name="controller">
          <DataItems>
            <DataItem category="CONDITION" id="Mazak01-controller_1" name="comms_cond" type="COMMUNICATIONS"/>
            <DataItem category="CONDITION" id="Mazak01-controller_2" name="logic_cond" type="LOGIC_PROGRAM"/>
            <DataItem category="CONDITION" id="Mazak01-controller_3" name="system_cond" type="SYSTEM"/>
            <DataItem category="EVENT" id="Mazak01-controller_4" name="estop" type="EMERGENCY_STOP"/>
          </DataItems>
          <Components>
            <Path id="Mazak01-path" name="path">
              <DataItems>
                <DataItem category="EVENT" id="Mazak01-path_1" name="program" type="PROGRAM"/>
                <DataItem category="EVENT" id="Mazak01-path_2" name="subprogram" subType="x:SUB" type="PROGRAM"/>
                <DataItem category="EVENT" id="Mazak01-path_3" name="line" type="LINE"/>
                <DataItem category="EVENT" id="Mazak01-path_4" name="unitNum" type="x:UNIT"/>
                <DataItem category="EVENT" id="Mazak01-path_5" name="sequenceNum" type="x:SEQUENCE_NUMBER"/>
                <DataItem category="EVENT" id="Mazak01-path_6" name="PartCountAct" type="PART_COUNT"/>
                <DataItem category="SAMPLE" coordinateSystem="WORK" id="Mazak01-path_7" name="Fact" nativeUnits="FOOT/MINUTE" subType="ACTUAL" type="PATH_FEEDRATE" units="MILLIMETER/SECOND"/>
                <DataItem category="EVENT" id="Mazak01-path_8" name="Frapidovr" nativeUnits="PERCENT" subType="RAPID" type="PATH_FEEDRATE_OVERRIDE" units="PERCENT"/>
                <DataItem category="EVENT" id="Mazak01-path_9" name="Fovr" nativeUnits="PERCENT" subType="PROGRAMMED" type="PATH_FEEDRATE_OVERRIDE" units="PERCENT"/>
                <DataItem category="EVENT" id="Mazak01-path_10" name="Tool_number" type="TOOL_NUMBER"/>
                <DataItem category="EVENT" id="Mazak01-path_11" name="Tool_group" type="x:TOOL_GROUP"/>
                <DataItem category="EVENT" id="Mazak01-path_12" name="Tool_suffix" type="x:TOOL_SUFFIX"/>
                <DataItem category="EVENT" id="Mazak01-path_13" name="execution" type="EXECUTION"/>
                <DataItem category="EVENT" id="Mazak01-path_14" name="mode" type="CONTROLLER_MODE"/>
                <DataItem category="EVENT" id="Mazak01-path_15" name="program_cmt" type="x:PROGRAM_COMMENT"/>
                <DataItem category="EVENT" id="Mazak01-path_16" name="subprogram_cmt" subType="x:SUB" type="x:PROGRAM_COMMENT"/>
                <DataItem category="SAMPLE" id="Mazak01-path_17" name="auto_time" subType="x:AUTO" type="ACCUMULATED_TIME"/>
                <DataItem category="SAMPLE" id="Mazak01-path_18" name="total_time" subType="x:TOTAL" type="ACCUMULATED_TIME"/>
                <DataItem category="SAMPLE" id="Mazak01-path_19" name="cut_time" subType="x:CUT" type="ACCUMULATED_TIME"/>
                <DataItem category="CONDITION" id="Mazak01-path_20" name="motion_cond" type="MOTION_PROGRAM"/>
                <DataItem category="CONDITION" id="Mazak01-path_21" name="path_system" type="SYSTEM"/>
              </DataItems>
            </Path>
          </Components>
        </Controller>
\end{lstlisting}

\begin{quote}
    \color{red} TODO: SensorConfiguration example for an axis.
\end{quote}

\subsection{MTConnect Streaming Data}

\subsubsection{Sample Data Items}

\subsubsection{Controlled Vocabulary Event Data Items}

\subsubsection{String Event Data Items}

\subsubsection{Numeric Event Data Items}

\subsubsection{Condition Data Items}
