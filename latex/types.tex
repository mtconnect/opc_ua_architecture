\subsection{Components}

\begin{figure}
  \centering
    \includegraphics[width=1.0\textwidth]{diagrams/Components.png}
  \caption{Components Diagram}
  \label{fig:Components}
\end{figure}

\FloatBarrier


The Components documents the Component models and the owned objects.

\subsubsection{Defintion of ChannelType} \label{type:ChannelType}

\FloatBarrier



\begin{table}
\centering 
  \caption{ChannelType Definition}
  \label{table:ChannelType}
\footnotesize
\tabulinesep=3pt
\begin{tabu} to 6in {|X[1.3]|X[1]|X[1.6]|X[2]|X[1.5]|X[1]|} \everyrow{\hline}
\hline
\rowfont\bfseries {Attribute} & \multicolumn{5}{|l|}{Value} \\
\tabucline[1.5pt]{}
BrowseName & \multicolumn{5}{|l|}{ChannelType} \\
IsAbstract & \multicolumn{5}{|l|}{False} \\
\tabucline[1.5pt]{}
\rowfont \bfseries References & NodeClass & BrowseName & DataType & TypeDefinition & {Modeling Rule} \\
\multicolumn{6}{|l|}{Subtype of BaseObjectType (See OPCUA Documentation)} \\
HasProperty & Variable & Number &  Int32 & PropertyType & Manditory \\
HasProperty & Variable & Name &  String & PropertyType & Optional \\
HasProperty & Variable & MTDescription &  String & PropertyType & Optional \\
HasProperty & Variable & CalibrationDate &  UtcTime & PropertyType & Optional \\
HasProperty & Variable & NextCalibrationDate &  UtcTime & PropertyType & Optional \\
HasProperty & Variable & CalibrationInitials &  String & PropertyType & Optional \\
\end{tabu}
\end{table} 

\FloatBarrier

\subsubsection{Defintion of DescriptionType} \label{type:DescriptionType}

\FloatBarrier

The desription provides some general information about the 
manufacture and serial number of the component. In the XML, the \texttt{CDATA} is freeform 
text that is represented in the \texttt{Data} Property of the Description Object.

\begin{table}
\centering 
  \caption{DescriptionType Definition}
  \label{table:DescriptionType}
\footnotesize
\tabulinesep=3pt
\begin{tabu} to 6in {|X[1.3]|X[1]|X[1.6]|X[2]|X[1.5]|X[1]|} \everyrow{\hline}
\hline
\rowfont\bfseries {Attribute} & \multicolumn{5}{|l|}{Value} \\
\tabucline[1.5pt]{}
BrowseName & \multicolumn{5}{|l|}{DescriptionType} \\
IsAbstract & \multicolumn{5}{|l|}{False} \\
\tabucline[1.5pt]{}
\rowfont \bfseries References & NodeClass & BrowseName & DataType & TypeDefinition & {Modeling Rule} \\
\multicolumn{6}{|l|}{Subtype of BaseObjectType (See OPCUA Documentation)} \\
HasProperty & Variable & Station &  String & PropertyType & Optional \\
HasProperty & Variable & SerialNumber &  String & PropertyType & Optional \\
HasProperty & Variable & Manufacturer &  String & PropertyType & Optional \\
HasProperty & Variable & Data &  String & PropertyType & Optional \\
\end{tabu}
\end{table} 

\FloatBarrier

\paragraph{Operations}

\begin{itemize}
  \item deriveBrowseName(element)\\
    Specification: \texttt{"Description"}

  \item deriveNodeId(element)\\
    Specification: \texttt{concat(self.parent.NodeId, BrowseName)}

\end{itemize}
\subsubsection{Defintion of MTComponentType} \label{type:MTComponentType}

\FloatBarrier

The base Component Type from which all MTConnect Components are derived from. The 
component type factory is used to create the specific OPC/UA types as subtypes of the 
MTConnect `MTComponentType`. The component types will be created once for all Component objects 
of that type based on the `QName` of the MTConnect XML element. 

The object factory will instantiate the Component Objects and insert them into the Components 
folder with a browse name of the Component QName and the `name` element if specified surrounded 
by square brackets, `[]`. For example if the MTConnect Element is:

`<Linear name='X'>...</...>`

The OPC/UA Object with browse name `Linear[X]` will be created with the HasTypeDefinition 
referencing the `Linear` OPC/UA type. 

The meta data for the component and it's relationships are static. The dynamic data will be 
represented using the _OPC/UA Part 8_ 



\begin{table}
\centering 
  \caption{MTComponentType Definition}
  \label{table:MTComponentType}
\footnotesize
\tabulinesep=3pt
\begin{tabu} to 6in {|X[1.3]|X[1]|X[1.6]|X[2]|X[1.5]|X[1]|} \everyrow{\hline}
\hline
\rowfont\bfseries {Attribute} & \multicolumn{5}{|l|}{Value} \\
\tabucline[1.5pt]{}
BrowseName & \multicolumn{5}{|l|}{MTComponentType} \\
IsAbstract & \multicolumn{5}{|l|}{True} \\
\tabucline[1.5pt]{}
\rowfont \bfseries References & NodeClass & BrowseName & DataType & TypeDefinition & {Modeling Rule} \\
HasProperty & Variable & Id &  IdType & PropertyType & Manditory \\
HasProperty & Variable & Name &  String & PropertyType & Optional \\
HasProperty & Variable & NativeName &  String & PropertyType & Optional \\
HasProperty & Variable & Uuid &  String & PropertyType & Optional \\
HasProperty & Variable & SampleRate &  float & PropertyType & Optional \\
HasProperty & Variable & SampleInterval &  float & PropertyType & Optional \\
HasComponent & Object & Description &   & DescriptionType & Optional \\
HasComponent & Object & Configuration &   & MTConfigurationType & Optional \\
Organizes & Object & Components &  MTComponentType & FolderType & Optional \\
Organizes & Object & Compositions &  MTCompositionType & FolderType & Optional \\
HasProperty & Variable & <Dynamic> &  {DataItem}Type & <Dynamic> & Optional \\
HasProperty & Variable & <Dynamic> &  BaseObjectType & <Dynamic> & Optional \\
Organizes & Object & Conditions &  MTNonExclusiveConditionType & FolderType & Optional \\
HasProperty & Variable & <Dynamic> &  {DataItem}Type & <Dynamic> & Manditory \\
\end{tabu}
\end{table} 

\FloatBarrier

\subsubsection{Defintion of MTCompositionType} \label{type:MTCompositionType}

\FloatBarrier



\begin{table}
\centering 
  \caption{MTCompositionType Definition}
  \label{table:MTCompositionType}
\footnotesize
\tabulinesep=3pt
\begin{tabu} to 6in {|X[1.3]|X[1]|X[1.6]|X[2]|X[1.5]|X[1]|} \everyrow{\hline}
\hline
\rowfont\bfseries {Attribute} & \multicolumn{5}{|l|}{Value} \\
\tabucline[1.5pt]{}
BrowseName & \multicolumn{5}{|l|}{MTCompositionType} \\
IsAbstract & \multicolumn{5}{|l|}{True} \\
\tabucline[1.5pt]{}
\rowfont \bfseries References & NodeClass & BrowseName & DataType & TypeDefinition & {Modeling Rule} \\
\multicolumn{6}{|l|}{Subtype of BaseObjectType (See OPCUA Documentation)} \\
HasProperty & Variable & Uuid &  String & PropertyType & Optional \\
HasProperty & Variable & Name &  String & PropertyType & Optional \\
HasProperty & Variable & MTDescription &  String & PropertyType & Optional \\
NonHierarchialReferenceType & Object & composition &  {DataItem}Type & NonHierarchialReferenceType & Optional \\
\end{tabu}
\end{table} 

\FloatBarrier

\subsubsection{Defintion of MTConfigurationType} \label{type:MTConfigurationType}

\FloatBarrier



\begin{table}
\centering 
  \caption{MTConfigurationType Definition}
  \label{table:MTConfigurationType}
\footnotesize
\tabulinesep=3pt
\begin{tabu} to 6in {|X[1.3]|X[1]|X[1.6]|X[2]|X[1.5]|X[1]|} \everyrow{\hline}
\hline
\rowfont\bfseries {Attribute} & \multicolumn{5}{|l|}{Value} \\
\tabucline[1.5pt]{}
BrowseName & \multicolumn{5}{|l|}{MTConfigurationType} \\
IsAbstract & \multicolumn{5}{|l|}{True} \\
\tabucline[1.5pt]{}
\rowfont \bfseries References & NodeClass & BrowseName & DataType & TypeDefinition & {Modeling Rule} \\
\multicolumn{6}{|l|}{Subtype of BaseObjectType (See OPCUA Documentation)} \\
\end{tabu}
\end{table} 

\FloatBarrier

\subsubsection{Defintion of MTDeviceType} \label{type:MTDeviceType}

\FloatBarrier

The MTDevice is a special type whose object will be the root of the device graph. The Device uses the component type factory and the component object factories to create each of the first level components. 

The  compositions, relationships, and data items are then recursively created as one decendes the MTConnect informaiton model.

\begin{table}
\centering 
  \caption{MTDeviceType Definition}
  \label{table:MTDeviceType}
\footnotesize
\tabulinesep=3pt
\begin{tabu} to 6in {|X[1.3]|X[1]|X[1.6]|X[2]|X[1.5]|X[1]|} \everyrow{\hline}
\hline
\rowfont\bfseries {Attribute} & \multicolumn{5}{|l|}{Value} \\
\tabucline[1.5pt]{}
BrowseName & \multicolumn{5}{|l|}{MTDeviceType} \\
IsAbstract & \multicolumn{5}{|l|}{False} \\
\tabucline[1.5pt]{}
\rowfont \bfseries References & NodeClass & BrowseName & DataType & TypeDefinition & {Modeling Rule} \\
\multicolumn{6}{|l|}{Subtype of MTComponentType (see section \ref{type:MTComponentType})} \\
HasProperty & Variable & Version &  String & PropertyType & Optional \\
HasProperty & Variable & Iso841Class &  String & PropertyType & Optional \\
\end{tabu}
\end{table} 

\FloatBarrier

\paragraph{Operations}

\begin{itemize}
  \item deriveBrowseName(element)\\
    Specification: \texttt{self.name}

  \item deriveNodeId(element)\\
    Specification: \texttt{self.uuid}

\end{itemize}
\subsubsection{Defintion of SensorConfigurationType} \label{type:SensorConfigurationType}

\FloatBarrier

The SensorConfiguration browse name will be created as an Object relationship with the parent component.

\begin{table}
\centering 
  \caption{SensorConfigurationType Definition}
  \label{table:SensorConfigurationType}
\footnotesize
\tabulinesep=3pt
\begin{tabu} to 6in {|X[1.3]|X[1]|X[1.6]|X[2]|X[1.5]|X[1]|} \everyrow{\hline}
\hline
\rowfont\bfseries {Attribute} & \multicolumn{5}{|l|}{Value} \\
\tabucline[1.5pt]{}
BrowseName & \multicolumn{5}{|l|}{SensorConfigurationType} \\
IsAbstract & \multicolumn{5}{|l|}{False} \\
\tabucline[1.5pt]{}
\rowfont \bfseries References & NodeClass & BrowseName & DataType & TypeDefinition & {Modeling Rule} \\
\multicolumn{6}{|l|}{Subtype of MTConfigurationType (see section \ref{type:MTConfigurationType})} \\
HasProperty & Variable & FirwareVersion &  String & PropertyType & Manditory \\
HasProperty & Variable & CalibrationDate &  UtcTime & PropertyType & Optional \\
HasProperty & Variable & NextCalibrationDate &  UtcTime & PropertyType & Optional \\
HasProperty & Variable & CalibrationInitials &  String & PropertyType & Optional \\
Organizes & Object & Channels &  ChannelType & FolderType & Optional \\
\end{tabu}
\end{table} 

\FloatBarrier

\subsubsection{Defintion of {Component}Type} \label{type:{Component}Type}

\FloatBarrier



\begin{table}
\centering 
  \caption{{Component}Type Definition}
  \label{table:{Component}Type}
\footnotesize
\tabulinesep=3pt
\begin{tabu} to 6in {|X[1.3]|X[1]|X[1.6]|X[2]|X[1.5]|X[1]|} \everyrow{\hline}
\hline
\rowfont\bfseries {Attribute} & \multicolumn{5}{|l|}{Value} \\
\tabucline[1.5pt]{}
BrowseName & \multicolumn{5}{|l|}{{Component}Type} \\
IsAbstract & \multicolumn{5}{|l|}{False} \\
\tabucline[1.5pt]{}
\rowfont \bfseries References & NodeClass & BrowseName & DataType & TypeDefinition & {Modeling Rule} \\
\multicolumn{6}{|l|}{Subtype of MTComponentType (see section \ref{type:MTComponentType})} \\
\end{tabu}
\end{table} 

\FloatBarrier

\subsubsection{Defintion of {Composition}Type} \label{type:{Composition}Type}

\FloatBarrier



\begin{table}
\centering 
  \caption{{Composition}Type Definition}
  \label{table:{Composition}Type}
\footnotesize
\tabulinesep=3pt
\begin{tabu} to 6in {|X[1.3]|X[1]|X[1.6]|X[2]|X[1.5]|X[1]|} \everyrow{\hline}
\hline
\rowfont\bfseries {Attribute} & \multicolumn{5}{|l|}{Value} \\
\tabucline[1.5pt]{}
BrowseName & \multicolumn{5}{|l|}{{Composition}Type} \\
IsAbstract & \multicolumn{5}{|l|}{False} \\
\tabucline[1.5pt]{}
\rowfont \bfseries References & NodeClass & BrowseName & DataType & TypeDefinition & {Modeling Rule} \\
\multicolumn{6}{|l|}{Subtype of MTCompositionType (see section \ref{type:MTCompositionType})} \\
\end{tabu}
\end{table} 

\FloatBarrier

\subsection{Data Items}

\begin{figure}
  \centering
    \includegraphics[width=1.0\textwidth]{diagrams/Data Items.png}
  \caption{Data Items Diagram}
  \label{fig:Data Items}
\end{figure}

\FloatBarrier




\subsubsection{Defintion of AssetChangedType} \label{type:AssetChangedType}

\FloatBarrier



\begin{table}
\centering 
  \caption{AssetChangedType Definition}
  \label{table:AssetChangedType}
\footnotesize
\tabulinesep=3pt
\begin{tabu} to 6in {|X[1.3]|X[1]|X[1.6]|X[2]|X[1.5]|X[1]|} \everyrow{\hline}
\hline
\rowfont\bfseries {Attribute} & \multicolumn{5}{|l|}{Value} \\
\tabucline[1.5pt]{}
BrowseName & \multicolumn{5}{|l|}{AssetChangedType} \\
IsAbstract & \multicolumn{5}{|l|}{False} \\
\tabucline[1.5pt]{}
\rowfont \bfseries References & NodeClass & BrowseName & DataType & TypeDefinition & {Modeling Rule} \\
\multicolumn{6}{|l|}{Subtype of AssetEventType (see section \ref{type:AssetEventType})} \\
\end{tabu}
\end{table} 

\FloatBarrier

\subsubsection{Defintion of AssetEventType} \label{type:AssetEventType}

\FloatBarrier



\begin{table}
\centering 
  \caption{AssetEventType Definition}
  \label{table:AssetEventType}
\footnotesize
\tabulinesep=3pt
\begin{tabu} to 6in {|X[1.3]|X[1]|X[1.6]|X[2]|X[1.5]|X[1]|} \everyrow{\hline}
\hline
\rowfont\bfseries {Attribute} & \multicolumn{5}{|l|}{Value} \\
\tabucline[1.5pt]{}
BrowseName & \multicolumn{5}{|l|}{AssetEventType} \\
IsAbstract & \multicolumn{5}{|l|}{False} \\
\tabucline[1.5pt]{}
\rowfont \bfseries References & NodeClass & BrowseName & DataType & TypeDefinition & {Modeling Rule} \\
\multicolumn{6}{|l|}{Subtype of MTStringEventType (see section \ref{type:MTStringEventType})} \\
HasProperty & Variable & AssetType &  String & PropertyType & Manditory \\
\end{tabu}
\end{table} 

\FloatBarrier

\subsubsection{Defintion of AssetRemovedType} \label{type:AssetRemovedType}

\FloatBarrier



\begin{table}
\centering 
  \caption{AssetRemovedType Definition}
  \label{table:AssetRemovedType}
\footnotesize
\tabulinesep=3pt
\begin{tabu} to 6in {|X[1.3]|X[1]|X[1.6]|X[2]|X[1.5]|X[1]|} \everyrow{\hline}
\hline
\rowfont\bfseries {Attribute} & \multicolumn{5}{|l|}{Value} \\
\tabucline[1.5pt]{}
BrowseName & \multicolumn{5}{|l|}{AssetRemovedType} \\
IsAbstract & \multicolumn{5}{|l|}{False} \\
\tabucline[1.5pt]{}
\rowfont \bfseries References & NodeClass & BrowseName & DataType & TypeDefinition & {Modeling Rule} \\
\multicolumn{6}{|l|}{Subtype of AssetEventType (see section \ref{type:AssetEventType})} \\
\end{tabu}
\end{table} 

\FloatBarrier

\subsubsection{Defintion of MTDataItemType} \label{type:MTDataItemType}

\FloatBarrier

The data item mixin will inject the properties and the methods into the related classes. This facility is similar to the Ruby module mixin or the Scala traits.

\begin{table}
\centering 
  \caption{MTDataItemType Definition}
  \label{table:MTDataItemType}
\footnotesize
\tabulinesep=3pt
\begin{tabu} to 6in {|X[1.3]|X[1]|X[1.6]|X[2]|X[1.5]|X[1]|} \everyrow{\hline}
\hline
\rowfont\bfseries {Attribute} & \multicolumn{5}{|l|}{Value} \\
\tabucline[1.5pt]{}
BrowseName & \multicolumn{5}{|l|}{MTDataItemType} \\
IsAbstract & \multicolumn{5}{|l|}{False} \\
\tabucline[1.5pt]{}
\rowfont \bfseries References & NodeClass & BrowseName & DataType & TypeDefinition & {Modeling Rule} \\
HasProperty & Variable & SourceName &  String & PropertyType & Optional \\
HasProperty & Variable & StreamRate &  Double & PropertyType & Optional \\
HasProperty & Variable & SampleRate &  Double & PropertyType & Optional \\
HasProperty & Variable & Representation &  RepresentationType & PropertyType & Optional \\
HasProperty & Variable & Category &  MTCategoryType & PropertyType & Optional \\
HasProperty & Variable & <Dynamic> &  MTFilterType & <Dynamic> & Optional \\
HasComponent & Object & source &   & BaseObjectType & Optional \\
\end{tabu}
\end{table} 

\FloatBarrier

\paragraph{Operations}

\begin{itemize}
  \item deriveSourceName(element)\\
    Specification: \texttt{self.Source.CDATA}
\\
    Documentation: Derive the source name from the Source element CDATA. This will represent the alternative long name for the data item's source.

  \item getStatusCode()\\
    Documentation: The OPC/UA status code will be created using the following process:

* If the value of the data item is `UNAVAILABLE` a status code of `Uncertain_NoCommunicationLastUsable`.
* When a reset trigger is specified, new `Good_` status codes will be created. See `ResetTrigger` enumeration.

\end{itemize}
\subsubsection{Defintion of MTEnumeratedEventType} \label{type:MTEnumeratedEventType}

\FloatBarrier

All Data Items with Category EVENT having a Controlled Vocabularies will be of this type. Otherwise, MTString

\begin{table}
\centering 
  \caption{MTEnumeratedEventType Definition}
  \label{table:MTEnumeratedEventType}
\footnotesize
\tabulinesep=3pt
\begin{tabu} to 6in {|X[1.3]|X[1]|X[1.6]|X[2]|X[1.5]|X[1]|} \everyrow{\hline}
\hline
\rowfont\bfseries {Attribute} & \multicolumn{5}{|l|}{Value} \\
\tabucline[1.5pt]{}
BrowseName & \multicolumn{5}{|l|}{MTEnumeratedEventType} \\
IsAbstract & \multicolumn{5}{|l|}{False} \\
\tabucline[1.5pt]{}
\rowfont \bfseries References & NodeClass & BrowseName & DataType & TypeDefinition & {Modeling Rule} \\
\multicolumn{6}{|l|}{Subtype of MultiStateValueDiscreteType (See OPCUA Documentation)} \\
HasProperty & Variable & ConstrainedValues &  EnumValuesType & PropertyType & Manditory \\
\end{tabu}
\end{table} 

\FloatBarrier

\subsubsection{Defintion of MTFilterType} \label{type:MTFilterType}

\FloatBarrier

These features will be subsumed by the OPC/UA client filtering directives.

\begin{table}
\centering 
  \caption{MTFilterType Definition}
  \label{table:MTFilterType}
\footnotesize
\tabulinesep=3pt
\begin{tabu} to 6in {|X[1.3]|X[1]|X[1.6]|X[2]|X[1.5]|X[1]|} \everyrow{\hline}
\hline
\rowfont\bfseries {Attribute} & \multicolumn{5}{|l|}{Value} \\
\tabucline[1.5pt]{}
BrowseName & \multicolumn{5}{|l|}{MTFilterType} \\
IsAbstract & \multicolumn{5}{|l|}{True} \\
\tabucline[1.5pt]{}
\rowfont \bfseries References & NodeClass & BrowseName & DataType & TypeDefinition & {Modeling Rule} \\
HasProperty & Variable & Value &  float & PropertyType & Manditory \\
\end{tabu}
\end{table} 

\FloatBarrier

\paragraph{Operations}

\begin{itemize}
  \item deriveBrowseName(element)\\
    Specification: \texttt{concat(parent.BrowseName, pascalCase(element.type))}

  \item deriveNodeId(element)\\
    Specification: \texttt{concat(parent.NodeId, pascalCase(element.type))}

\end{itemize}
\subsubsection{Defintion of MTMessageType} \label{type:MTMessageType}

\FloatBarrier



\begin{table}
\centering 
  \caption{MTMessageType Definition}
  \label{table:MTMessageType}
\footnotesize
\tabulinesep=3pt
\begin{tabu} to 6in {|X[1.3]|X[1]|X[1.6]|X[2]|X[1.5]|X[1]|} \everyrow{\hline}
\hline
\rowfont\bfseries {Attribute} & \multicolumn{5}{|l|}{Value} \\
\tabucline[1.5pt]{}
BrowseName & \multicolumn{5}{|l|}{MTMessageType} \\
IsAbstract & \multicolumn{5}{|l|}{False} \\
\tabucline[1.5pt]{}
\rowfont \bfseries References & NodeClass & BrowseName & DataType & TypeDefinition & {Modeling Rule} \\
\multicolumn{6}{|l|}{Subtype of MTStringEventType (see section \ref{type:MTStringEventType})} \\
HasProperty & Variable & NativeCode &  String & PropertyType & Optional \\
\end{tabu}
\end{table} 

\FloatBarrier

\subsubsection{Defintion of MTNumericDataItemType} \label{type:MTNumericDataItemType}

\FloatBarrier

These are the additional attributes that are relevent to numeric data items. The factory will evaluate these values and will set the engineering units and the range associated with the parent entity.

\begin{table}
\centering 
  \caption{MTNumericDataItemType Definition}
  \label{table:MTNumericDataItemType}
\footnotesize
\tabulinesep=3pt
\begin{tabu} to 6in {|X[1.3]|X[1]|X[1.6]|X[2]|X[1.5]|X[1]|} \everyrow{\hline}
\hline
\rowfont\bfseries {Attribute} & \multicolumn{5}{|l|}{Value} \\
\tabucline[1.5pt]{}
BrowseName & \multicolumn{5}{|l|}{MTNumericDataItemType} \\
IsAbstract & \multicolumn{5}{|l|}{False} \\
\tabucline[1.5pt]{}
\rowfont \bfseries References & NodeClass & BrowseName & DataType & TypeDefinition & {Modeling Rule} \\
\multicolumn{6}{|l|}{Subtype of MTDataItemType (see section \ref{type:MTDataItemType})} \\
HasProperty & Variable & SignificantDigits &  UInt16 & PropertyType & Optional \\
HasProperty & Variable & Statistic &  MTStatisticType & PropertyType & Optional \\
HasProperty & Variable & Units &  MTUnits & PropertyType & Optional \\
HasProperty & Variable & NativeUnits &  MTNativeUnitsType & PropertyType & Optional \\
HasProperty & Variable & CoordinateSystem &  MTCoordinateSystemType & PropertyType & Optional \\
HasProperty & Variable & InitialValue &  Double & PropertyType & Optional \\
HasProperty & Variable & ResetTrigger &  DataItemResetValueType & PropertyType & Optional \\
HasProperty & Variable & Nominal &  Double & PropertyType & Optional \\
\end{tabu}
\end{table} 

\FloatBarrier

\paragraph{Operations}

\begin{itemize}
  \item deriveEngineeringUnits(units)\\
    Specification: \texttt{EngineeringUnits <- self.units}

  \item deriveEURange(constraints)\\
    Specification: \texttt{EURange.Low <- self.Constraints.Minimum
EURange.High <- self.Constraints.Maximum}
\\
    Documentation: Uses the MTConnect Constraints element if present to derive the minimum and maximum values for the numeric values. This applies to both the Numeric Event and the Sample types.

\end{itemize}
\subsubsection{Defintion of MTNumericEventType} \label{type:MTNumericEventType}

\FloatBarrier

All data items with category EVENT and a numeric value.

\begin{table}
\centering 
  \caption{MTNumericEventType Definition}
  \label{table:MTNumericEventType}
\footnotesize
\tabulinesep=3pt
\begin{tabu} to 6in {|X[1.3]|X[1]|X[1.6]|X[2]|X[1.5]|X[1]|} \everyrow{\hline}
\hline
\rowfont\bfseries {Attribute} & \multicolumn{5}{|l|}{Value} \\
\tabucline[1.5pt]{}
BrowseName & \multicolumn{5}{|l|}{MTNumericEventType} \\
IsAbstract & \multicolumn{5}{|l|}{False} \\
\tabucline[1.5pt]{}
\rowfont \bfseries References & NodeClass & BrowseName & DataType & TypeDefinition & {Modeling Rule} \\
\multicolumn{6}{|l|}{Subtype of DataItemType (See OPCUA Documentation)} \\
HasProperty & Variable & EURange &  Range & PropertyType & Optional \\
HasProperty & Variable & EngineeringUnits &  EUInformation & PropertyType & Optional \\
\end{tabu}
\end{table} 

\FloatBarrier

\subsubsection{Defintion of MTSampleType} \label{type:MTSampleType}

\FloatBarrier

Data Items with category SAMPLE

\begin{table}
\centering 
  \caption{MTSampleType Definition}
  \label{table:MTSampleType}
\footnotesize
\tabulinesep=3pt
\begin{tabu} to 6in {|X[1.3]|X[1]|X[1.6]|X[2]|X[1.5]|X[1]|} \everyrow{\hline}
\hline
\rowfont\bfseries {Attribute} & \multicolumn{5}{|l|}{Value} \\
\tabucline[1.5pt]{}
BrowseName & \multicolumn{5}{|l|}{MTSampleType} \\
IsAbstract & \multicolumn{5}{|l|}{False} \\
\tabucline[1.5pt]{}
\rowfont \bfseries References & NodeClass & BrowseName & DataType & TypeDefinition & {Modeling Rule} \\
\multicolumn{6}{|l|}{Subtype of AnalogItemType (See OPCUA Documentation)} \\
\end{tabu}
\end{table} 

\FloatBarrier

\subsubsection{Defintion of MTStringEventType} \label{type:MTStringEventType}

\FloatBarrier

All data items with category EVENT where the data is freeform text. The set_data_type constraint derives  makes the data type a string for this type.

\begin{table}
\centering 
  \caption{MTStringEventType Definition}
  \label{table:MTStringEventType}
\footnotesize
\tabulinesep=3pt
\begin{tabu} to 6in {|X[1.3]|X[1]|X[1.6]|X[2]|X[1.5]|X[1]|} \everyrow{\hline}
\hline
\rowfont\bfseries {Attribute} & \multicolumn{5}{|l|}{Value} \\
\tabucline[1.5pt]{}
BrowseName & \multicolumn{5}{|l|}{MTStringEventType} \\
IsAbstract & \multicolumn{5}{|l|}{False} \\
\tabucline[1.5pt]{}
\rowfont \bfseries References & NodeClass & BrowseName & DataType & TypeDefinition & {Modeling Rule} \\
\multicolumn{6}{|l|}{Subtype of BaseDataVariableType (See OPCUA Documentation)} \\
\end{tabu}
\end{table} 

\FloatBarrier

\subsubsection{Defintion of MinimumDeltaFilterType} \label{type:MinimumDeltaFilterType}

\FloatBarrier



\begin{table}
\centering 
  \caption{MinimumDeltaFilterType Definition}
  \label{table:MinimumDeltaFilterType}
\footnotesize
\tabulinesep=3pt
\begin{tabu} to 6in {|X[1.3]|X[1]|X[1.6]|X[2]|X[1.5]|X[1]|} \everyrow{\hline}
\hline
\rowfont\bfseries {Attribute} & \multicolumn{5}{|l|}{Value} \\
\tabucline[1.5pt]{}
BrowseName & \multicolumn{5}{|l|}{MinimumDeltaFilterType} \\
IsAbstract & \multicolumn{5}{|l|}{False} \\
\tabucline[1.5pt]{}
\rowfont \bfseries References & NodeClass & BrowseName & DataType & TypeDefinition & {Modeling Rule} \\
\multicolumn{6}{|l|}{Subtype of MTFilterType (see section \ref{type:MTFilterType})} \\
\end{tabu}
\end{table} 

\FloatBarrier

\subsubsection{Defintion of PeriodFilterType} \label{type:PeriodFilterType}

\FloatBarrier



\begin{table}
\centering 
  \caption{PeriodFilterType Definition}
  \label{table:PeriodFilterType}
\footnotesize
\tabulinesep=3pt
\begin{tabu} to 6in {|X[1.3]|X[1]|X[1.6]|X[2]|X[1.5]|X[1]|} \everyrow{\hline}
\hline
\rowfont\bfseries {Attribute} & \multicolumn{5}{|l|}{Value} \\
\tabucline[1.5pt]{}
BrowseName & \multicolumn{5}{|l|}{PeriodFilterType} \\
IsAbstract & \multicolumn{5}{|l|}{False} \\
\tabucline[1.5pt]{}
\rowfont \bfseries References & NodeClass & BrowseName & DataType & TypeDefinition & {Modeling Rule} \\
\multicolumn{6}{|l|}{Subtype of MTFilterType (see section \ref{type:MTFilterType})} \\
\end{tabu}
\end{table} 

\FloatBarrier

\subsubsection{Defintion of {DataItem}Type} \label{type:{DataItem}Type}

\FloatBarrier

For each DataItem the Sub Type, and the Type will be composed to be the  HasTypeDefinition relationship of the object. The BrowseName will also include the Composition Type if a composition Id is provided.

\begin{table}
\centering 
  \caption{{DataItem}Type Definition}
  \label{table:{DataItem}Type}
\footnotesize
\tabulinesep=3pt
\begin{tabu} to 6in {|X[1.3]|X[1]|X[1.6]|X[2]|X[1.5]|X[1]|} \everyrow{\hline}
\hline
\rowfont\bfseries {Attribute} & \multicolumn{5}{|l|}{Value} \\
\tabucline[1.5pt]{}
BrowseName & \multicolumn{5}{|l|}{{DataItem}Type} \\
IsAbstract & \multicolumn{5}{|l|}{False} \\
\tabucline[1.5pt]{}
\rowfont \bfseries References & NodeClass & BrowseName & DataType & TypeDefinition & {Modeling Rule} \\
\multicolumn{6}{|l|}{Subtype of MTNumericEventType (see section \ref{type:MTNumericEventType})} \\
\end{tabu}
\end{table} 

\FloatBarrier

\subsection{Conditions}

\begin{figure}
  \centering
    \includegraphics[width=1.0\textwidth]{diagrams/Conditions.png}
  \caption{Conditions Diagram}
  \label{fig:Conditions}
\end{figure}

\FloatBarrier




\subsubsection{Defintion of MTExclusiveLimitConditionType} \label{type:MTExclusiveLimitConditionType}

\FloatBarrier



\begin{table}
\centering 
  \caption{MTExclusiveLimitConditionType Definition}
  \label{table:MTExclusiveLimitConditionType}
\footnotesize
\tabulinesep=3pt
\begin{tabu} to 6in {|X[1.3]|X[1]|X[1.6]|X[2]|X[1.5]|X[1]|} \everyrow{\hline}
\hline
\rowfont\bfseries {Attribute} & \multicolumn{5}{|l|}{Value} \\
\tabucline[1.5pt]{}
BrowseName & \multicolumn{5}{|l|}{MTExclusiveLimitConditionType} \\
IsAbstract & \multicolumn{5}{|l|}{False} \\
\tabucline[1.5pt]{}
\rowfont \bfseries References & NodeClass & BrowseName & DataType & TypeDefinition & {Modeling Rule} \\
\multicolumn{6}{|l|}{Subtype of ExclusiveLimitAlarmType (See OPCUA Documentation)} \\
\end{tabu}
\end{table} 

\FloatBarrier

\subsubsection{Defintion of MTNonExclusiveConditionType} \label{type:MTNonExclusiveConditionType}

\FloatBarrier



\begin{table}
\centering 
  \caption{MTNonExclusiveConditionType Definition}
  \label{table:MTNonExclusiveConditionType}
\footnotesize
\tabulinesep=3pt
\begin{tabu} to 6in {|X[1.3]|X[1]|X[1.6]|X[2]|X[1.5]|X[1]|} \everyrow{\hline}
\hline
\rowfont\bfseries {Attribute} & \multicolumn{5}{|l|}{Value} \\
\tabucline[1.5pt]{}
BrowseName & \multicolumn{5}{|l|}{MTNonExclusiveConditionType} \\
IsAbstract & \multicolumn{5}{|l|}{False} \\
\tabucline[1.5pt]{}
\rowfont \bfseries References & NodeClass & BrowseName & DataType & TypeDefinition & {Modeling Rule} \\
\multicolumn{6}{|l|}{Subtype of NonEclusiveLimitAlarmType (See OPCUA Documentation)} \\
\end{tabu}
\end{table} 

\FloatBarrier

\subsubsection{Defintion of {ConditionClass}Type} \label{type:{ConditionClass}Type}

\FloatBarrier



\begin{table}
\centering 
  \caption{{ConditionClass}Type Definition}
  \label{table:{ConditionClass}Type}
\footnotesize
\tabulinesep=3pt
\begin{tabu} to 6in {|X[1.3]|X[1]|X[1.6]|X[2]|X[1.5]|X[1]|} \everyrow{\hline}
\hline
\rowfont\bfseries {Attribute} & \multicolumn{5}{|l|}{Value} \\
\tabucline[1.5pt]{}
BrowseName & \multicolumn{5}{|l|}{{ConditionClass}Type} \\
IsAbstract & \multicolumn{5}{|l|}{False} \\
\tabucline[1.5pt]{}
\rowfont \bfseries References & NodeClass & BrowseName & DataType & TypeDefinition & {Modeling Rule} \\
\multicolumn{6}{|l|}{Subtype of SystemConditionClassType (See OPCUA Documentation)} \\
\end{tabu}
\end{table} 

\FloatBarrier

\subsection{Factories}

\begin{figure}
  \centering
    \includegraphics[width=1.0\textwidth]{diagrams/Factories.png}
  \caption{Factories Diagram}
  \label{fig:Factories}
\end{figure}

\FloatBarrier


The factories are not part of the OPC/UA information model. They are a set of helper 
classes that are used to create dynamic types and objects. Since the MTConnect 
information model can be layered on top of the OPC/UA abstrations, the factories
provide the rules for creating the browse and display names for each type.

The factories also create dynamic objects when requried for variables of various
classes when they are required, such as the Data Items and the Components. Some of the
relationships are more complex since they require a dynamic super-type relationship that
relies on the correct placement of the MTConnect elements to be correctly 
represented using the OPC/UA base types.

This is especially evident when mapping the DataItems and the Conditions to the 
MTConnect Information Models and providing sufficent definition to allow for 
unambiguous implementation.

\subsubsection{Defintion of ComponentObjectFactory} \label{type:ComponentObjectFactory}

\FloatBarrier



\paragraph{Operations}

\begin{itemize}
  \item deriveBrowseName(element)\\
    Specification: \texttt{concat(element.QName, (if self.name.notEmpty() then concat('[', self.name, ']')) else  '' endif))}

  \item deriveNodeId(element)\\
    Specification: \texttt{concat(self.findDevice().uuid, element.id)}

\end{itemize}
\subsubsection{Defintion of ComponentTypeFactory} \label{type:ComponentTypeFactory}

\FloatBarrier

The `ComponentTypeFactory` creates component types using the MTConnect XML element as an input. 
The factory takes the `QName` (or qualified name) of the XML element and then appends `Type`. For 
example an `<Controller id='...'></...>` element will create an OPC/UA `ControllerType` type definition 
as an extension of the base `MTControllerType`. 

Currently there is no additional abstractions or super types required by the companion specification. 
The types will be a single level where each Component is a sub-type of the base `MTComponentType`.


\paragraph{Operations}

\begin{itemize}
  \item deriveTypeName(element)\\
    Specification: \texttt{derive: Component <- element.QName}
\\
    Documentation: The QName of the element for the component will be used to derive the type of the node.

\end{itemize}
\subsubsection{Defintion of CompositionObjectFactory} \label{type:CompositionObjectFactory}

\FloatBarrier



\paragraph{Operations}

\begin{itemize}
  \item deriveBrowseName(element)\\
    Specification: \texttt{concat(pascalCase(element.type), (if self.name.notEmpty() then concat('[', self.name, ']')) else  '' endif))}

  \item deriveNodeId(element)\\
    Specification: \texttt{concat(self.findDevice().uuid, element.id)}

\end{itemize}
\subsubsection{Defintion of CompositionTypeFactory} \label{type:CompositionTypeFactory}

\FloatBarrier



\paragraph{Operations}

\begin{itemize}
  \item deriveTypeName(element)\\
    Specification: \texttt{derive: Composition <-
 pascalCase(element.type)}
\\
    Documentation: The type for the composition will be created using the pascal case of the `type` from the composition element.

\end{itemize}
\subsubsection{Defintion of ConditionClassFactory} \label{type:ConditionClassFactory}

\FloatBarrier



\paragraph{Operations}

\begin{itemize}
  \item deriveTypeName(element)\\
    Documentation: Create condition classes based on the OPC/UA three condition  types.

\end{itemize}
\subsubsection{Defintion of ConditionObjectFactory} \label{type:ConditionObjectFactory}

\FloatBarrier



\paragraph{Operations}

\begin{itemize}
  \item deriveBrowseName(element)
  \item deriveNodeId(element)
\end{itemize}
\subsubsection{Defintion of DataItemObjectFactory} \label{type:DataItemObjectFactory}

\FloatBarrier



\paragraph{Operations}

\begin{itemize}
  \item deriveSourceRelation(element)\\
    Documentation: Use the source composition,  component id, or data item id to locate the source node id for this relationship. If one exists, add an object with  browse name "source" that relates to the entity referenced by the id. 

The most specific identity should be used in the following order:
* DataItemId
* CompositionId
* ComponentId 

Since the data item implies composition and component and the composition implies component, there should only be one attribute given for the source.

  \item deriveDisplayName(element)\\
    Documentation: Same as the BrowseName.

  \item deriveNodeId(element)\\
    Documentation: The nodeId will be given by the device uuid and the DataItem id attribute.

  \item deriveBrowseName(element)\\
    Documentation: The browse name will be composed of the following parts of the model:

1. If the compositionId is present, the compositionId will be resolved the the Composition element and the pascal case of the type attribute will be placed first.
2. If the subType is present, the pascal case of the subType will be placed next.
3. The pascal case of the type will be placed last.

For example, for a data item with the following attributes:

* type: TEMPERATURE
* composition type: STORAGE_BATTERY

will have the browseName "StorageBatteryTemperature"

For the data item with the following attributes:

* type: ANGLE
* subType: ACTUAL
* composition type: ENCODER

will have the following browse name: "EncoderActualAngle"


\end{itemize}
\subsubsection{Defintion of DataItemTypeFactory} \label{type:DataItemTypeFactory}

\FloatBarrier

Based on the data item category, type, and subType, this class creates a new OPC/UA type and also provides the template parameter for the ParentType from which this type is derived. 

See the Data Item Type Factory.

\paragraph{Operations}

\begin{itemize}
  \item deriveParentType(type, subType)\\
    Documentation: The parent type is derived from the category as follows: 

* SAMPLE -> SampleType
* EVENT -> 
  * Enumerated Value -> MTEnumeratedEventType
  * Integer Value -> MTNumericEventType
  * Otherwise -> MTStringEventType

  \item deriveTypeName(type, subType)\\
    Specification: \texttt{concat(pascalCase(subType), pascalCase(type))}
\\
    Documentation: Used to derive the class name for creating a pascal case name from the sub type and the type. For example type ROTARY_VELOCITY and subType ACTUAL will become ActualRotaryVelocity.

\end{itemize}
\subsubsection{Defintion of DeviceObjectFactory} \label{type:DeviceObjectFactory}

\FloatBarrier

The model instantiation for MTConnect begins with the `Device` MTConnect element and then recursively traverses the sub-elements. The device will the capabilities in the component factory to generate all the data items and component types. 

\paragraph{Operations}

\begin{itemize}
  \item deriveBrowseName(element)\\
    Specification: \texttt{derive: element.name}

  \item deriveNodeId(element)\\
    Specification: \texttt{derive: element.uuid}

  \item Operation1()
\end{itemize}
\subsubsection{Defintion of FilterObjectFactory} \label{type:FilterObjectFactory}

\FloatBarrier

Creates filters based on the type attribute of the Filter element. 

\paragraph{Operations}

\begin{itemize}
  \item deriveBrowseName(element)
  \item deriveNodeId(element)\\
    Documentation: The node id is composed of the data item id and the browse name.

\end{itemize}
\subsubsection{Defintion of ObjectFactory} \label{type:ObjectFactory}

\FloatBarrier



\paragraph{Operations}

\begin{itemize}
  \item deriveBrowseName(element)
  \item deriveNodeId(element)
  \item deriveDisplayName(element)\\
    Specification: \texttt{deriveBrowseName(element)}

  \item createObject(element)
\end{itemize}
\subsubsection{Defintion of SensorChannelObjectFactory} \label{type:SensorChannelObjectFactory}

\FloatBarrier



\paragraph{Operations}

\begin{itemize}
  \item deriveBrowseName(element)\\
    Specification: \texttt{concat('Channel', self.number)}

  \item deriveNodeId(element)\\
    Specification: \texttt{concat(self.parent.NodeId, BrowseName)}

\end{itemize}
\subsubsection{Defintion of SensorObjectFactory} \label{type:SensorObjectFactory}

\FloatBarrier



\paragraph{Operations}

\begin{itemize}
  \item deriveBrowseName(element)\\
    Specification: \texttt{element.QName}

  \item deriveNodeId(element)\\
    Specification: \texttt{concat(self.parent.NodeId, BrowseName)}

\end{itemize}
\subsubsection{Defintion of TypeFactory} \label{type:TypeFactory}

\FloatBarrier



\paragraph{Operations}

\begin{itemize}
  \item deriveTypeName(element)
  \item createType(element)
\end{itemize}
\subsection{MTConnect Device Profile}

\begin{figure}
  \centering
    \includegraphics[width=1.0\textwidth]{diagrams/MTConnect Device Profile.png}
  \caption{MTConnect Device Profile Diagram}
  \label{fig:MTConnect Device Profile}
\end{figure}

\FloatBarrier


The device profile documents the common data types and stereotypes that are 
used to construct the model. A stereotype is a design or modeling pattern that 
provides additional information about the type or the relationship between types. 

It can also identify the behavior of a property or the role the type or relation
will play in the model. 

Stereotypes are used throughout the model to provide additional information that 
will halp provide context and definition to aid in better understanding the
data model.

\subsubsection{Defintion of Dynamic Type} \label{type:Dynamic Type}

\FloatBarrier



\subsubsection{Defintion of MIxes In} \label{type:MIxes In}

\FloatBarrier



\subsubsection{Defintion of MTConnect XML} \label{type:MTConnect XML}

\FloatBarrier



\subsubsection{Defintion of MTRelationshipType} \label{type:MTRelationshipType}

\FloatBarrier



\subsubsection{Defintion of Object Factory} \label{type:Object Factory}

\FloatBarrier



\subsubsection{Defintion of Type Factory} \label{type:Type Factory}

\FloatBarrier



\subsubsection{Defintion of bind} \label{type:bind}

\FloatBarrier



\subsubsection{Defintion of constrains} \label{type:constrains}

\FloatBarrier



\subsubsection{Defintion of mixin} \label{type:mixin}

\FloatBarrier

The contents properties and the behavior of the class are combined with another class.

\subsubsection{Defintion of use} \label{type:use}

\FloatBarrier

The use stereotype indicates that one class uses as a helper to perform 
a specific operation or activity. This stereotype is mainly used to indicate
that a specific factory is being employed by another type to create dynamic
properties or relationships.

